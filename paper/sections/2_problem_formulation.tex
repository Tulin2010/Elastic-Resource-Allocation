\section{Problem formulation}\label{sec:problem-formulation}
In this section, an outline of the system model describes servers and tasks (subsection~\ref{subsec:system-model})
which is used in constructing an optimisation problem for the flexible resource allocation
(subsection~\ref{subsec:optimisation-problem}). Finally, an example problem is used to demonstrate the effectiveness of
this flexible resource allocation scheme compared to a fixed resource allocation scheme in previous work.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\linewidth]{figs/system_model.pdf}
    \caption{System Model}
    \label{fig:system-model}
\end{figure}

\subsection{System model}\label{subsec:system-model}
A sketch of the system is shown in Fig.~\ref{fig:system-model}.
We assume that there are a set of servers $I = \{1,2,\ldots,\left|I\right|\}$, which could be accessed either through
cellular base stations or WiFi access points (APs). These servers have different types of limited resources:
storage for the code/data needed to run a task (e.g., measured in Gb), computation capacity in terms of CPU cycles per
time interval (e.g., measured in FLOP/s), and communication bandwidth to receive the data and to send back the results
of the task after execution (e.g., measured in Mbit/s). The server are assume to only consider these attribute for
resource allocation, however future work would wish to explore additional attributes like I/O memory access per second,
GPU capacity and more. These servers are assumed to be heterogeneous in all their characteristics. Formally, we denote
the storage capacity of server $i$ with $S_i$, computation capacity with $W_i$, and the bandwidth capacity with $R_i$.

The system also contains a set $J = \{1,2,\ldots,\left| J \right|\}$ different tasks that each require service from one
of the servers $I$.
\footnote{We focus on a single-shot setting in this paper. In practice, an allocation mechanism would repeat the
allocation decisions described here over regular time intervals, with longer-running tasks re-appearing on consecutive
time intervals. We leave a detailed study of this to future work.} Each task has a monetary value, denoted $v_j$,
representing the price the owner is willing to pay to compute the task. \\
In order to run a task requires the server to load the appropriate code/data on the server from a source, then to
compute the code of the task and to send back results to the user. Therefore for each of these stages, we consider
separate speeds that the operations could occur at to enable flexibility for the server at each point. \\
The storage size for the task $j$ is denoted as $s_j$ with the rate that the program is transferred to the server
as $s^{'}_j$. For a task to be computed successfully, it must fetch and execute instructions on a CPU. We consider the
total number of CPU cycles required for the program to be $w_j$, where the number of CPU cycles assigned to the task
per unit of time as $w^{'}_j$. Finally, after the task is run and the results obtained, the latter need to be sent back
to the user. The size of the results for task $j$ is denoted with $r_j$, and the bandwidth used to sent back results to
the user as $r^{'}_j$.
In order to force the server to complete the task with a reasonable time, each task sets a deadline, denoted by $d_j$,
representing the maximum amount of time for a task to be completed successfully within. This includes: the time
required to load the data/code onto the server, run it, and send back results to the user. \\
We assume that there is an \emph{all} or \emph{nothing} task execution reward scheme, meaning that the task value is
awarded only if the task is completed within its deadline.

\subsection{Optimisation problem}\label{subsec:optimisation-problem}
Given the aforementioned assumptions and variables from the system model, an optimisation problem is constructed as
followed. This problem uses the additional variable $x_{i,j}$ to denote the allocation of a task $j$ that will run on
server $i$.

%% TODO A problem exists that you must allocate the resources and determine the server at the same time

\begin{align}
    \max & \sum_{\forall j \in J} v_j \left(\sum_{\forall i \in I} x_{i,j}\right) \label{eq:objective} \\
    \mbox{s.t.} \nonumber \\
    & \sum_{\forall j \in J} s_j x_{i,j} \leq S_i, &~ \forall{i \in I} \label{eq:server-storage-constraint} \\
    & \sum_{\forall j \in J} w^{'}_j x_{i,j} \leq W_i, &~ \forall{i \in I} \label{eq:server-computation-constraint} \\
    & \sum_{\forall j \in J} (r^{'}_j + s^{'}_j) \cdot x_{i,j} \leq R_i, &~ \forall{i \in I} \label{eq:server-bandwidth-constraint} \\
    & \frac{s_j}{s^{'}_j} + \frac{w_j}{w^{'}_j} + \frac{r_j}{r^{'}_j} \leq d_j, &~ \forall{j \in J} \label{eq:task-deadline} \\
    & 0 < s^{'}_j, &~ \forall{j \in J} \label{eq:loading-speeds} \\
    & 0 < w^{'}_j, &~ \forall{j \in J} \label{eq:compute-speeds} \\
    & 0 < r^{'}_j, &~ \forall{j \in J} \label{eq:sending-speeds} \\
    & \sum_{\forall i \in I} x_{i,j} \leq 1, &~ \forall{j \in J} \label{eq:server-task-allocation} \\
    & x_{i,j} \in \{0, 1\}, &~ \forall{i \in I},\forall{j \in J} \label{eq:task-allocation}
\end{align}

The objective (eq.~\ref{eq:objective}) is to maximize the total value over all tasks (i.e.\ social welfare) that
are completed within their deadline (eq.~\ref{eq:task-deadline}).
Constraints~\ref{eq:server-storage-constraint},~\ref{eq:server-computation-constraint}
and~\ref{eq:server-bandwidth-constraint} prevent over allocation of server resources to allocated tasks.
For the server's storage capacity (constraint~\ref{eq:server-storage-constraint}), each server's storage must be less
than allocated task's storage requirements. While for the server's computational capacity
(constraint~\ref{eq:server-computation-constraint}), the capacity is limited by a server's allocated tasks
compute resources ($w^{'}_j$). The server's bandwidth capacity (constraint~\ref{eq:server-bandwidth-constraint})
comprises of two parts: the first for loading fo data/code of a task onto the server and the second for sending
back result to the user. \\
To force the task to the completed within its assigned deadline, constraint~\ref{eq:task-deadline} required the sum
of time taken for each stages of the task, completed in series, to be less than the deadline value.
Note that if a task is not allocated to any server, this constraint can be satisfied by choosing arbitrarily
resource speed as these resources do not use up any servers' resources in
constraint~\ref{eq:server-storage-constraint},~\ref{eq:server-computation-constraint}
or~\ref{eq:server-bandwidth-constraint}. \\
Constraints~\ref{eq:loading-speeds},~\ref{eq:compute-speeds},~\ref{eq:sending-speeds} enforce that the resource
speeds for each stage ($s^{'}_j$, $w^{'}_j$ and $r^{'}_j$) are all positive and finite.
Finally, as every task can only be served by at most one server, constraints~\ref{eq:server-task-allocation}
and~\ref{eq:task-allocation} enforce this.

As the optimisation problem as described below is an extension of the Knapsack problem which is well-studied and
known to be NP-Hard, the optimisation problem is NP-Hard as well.

\begin{theorem}
    The optimisation problem in subsection~\ref{subsec:optimisation-problem} is NP-hard.
\end{theorem}
\begin{proof}
    The optimization problem without the constraint~\ref{eq:task-deadline} is a 0--1 multidimensional knapsack
    problem~\cite{knapsackproblems_2004}, which is a generalization of a simple 0--1 knapsack problem. The latter is an
    NP-hard problem~\cite{knapsackproblems_2004}. Given this, it follows that the 0--1 multidimensional knapsack problem
    is also NP-hard. Since optimization problem (Eqs~\ref{eq:objective} -~\ref{eq:task-allocation}) is a
    generalization of a 0--1 multidimensional knapsack problem, it follows that it is NP-hard as well.
\end{proof}

\subsection{Example Problem Case}\label{subsec:example-problem-case}
Before we propose our novel allocation mechanisms for the allocation problem with elastic resources, we briefly
outline an example to illustrates why considering elasticity is important. In this example, there are 12 potential
tasks and 3 servers (the exact settings can be found in table~\ref{tab:example-tasks-properties} for the tasks and
table~\ref{tab:example-servers-properties} for the servers). The figures~\ref{fig:fixed-resources-speeds}
and~\ref{fig:flexible-resources-speeds} represents each server as a group of three bars, each relating to the each
server's resource types, with the percentage of resources used by a task being the size of the bar.

\begin{figure}[th]
    \centering
    \includegraphics[width=\linewidth]{figs/allocation/fixed_resource_allocation.png}
    \caption{Optimal solution with fixed resource speeds}
    \label{fig:fixed-resources-speeds}
\end{figure}

Figure~\ref{fig:fixed-resources-speeds} shows the best possible allocation if tasks have fixed resource speeds (that
were set by minimising the total amount of resources to be completed within the deadline). Here, only 9 of the tasks
are run, resulting in a total social welfare of 980 due to server 1 and 2's limited computational capacity and server
3' limited communication capacity.

\begin{figure}[th]
    \centering
    \includegraphics[width=\linewidth]{figs/allocation/flexible_resource_allocation.png}
    \caption{Optimal solution with elastic resources speeds}
    \label{fig:flexible-resources-speeds}
\end{figure}

In contrast to figure~\ref{fig:fixed-resources-speeds}, Figure~\ref{fig:flexible-resources-speeds} depicts the optimal
allocation if elastic resources are considered. Here, all of the resources are used by the servers whereas the fixed
example~\ref{fig:fixed-resources-speeds} cant do this. In total, the elastic approach manages to schedule all 12 tasks
within the resource constraints, achieving a total social welfare of 1200 (an 18\% improvement over the fixed approach).