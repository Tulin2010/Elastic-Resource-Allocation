\section{Problem formulation}
\label{sec:problem-formulation}
In this section, an outline of the system model describes servers and tasks attributes (subsection~\ref{subsec:system-model})
that is used in constructing an optimisation problem for the flexible resource allocation
(subsection~\ref{subsec:optimisation-problem}). Finally, an example problem is used to demonstrate the effectiveness of
our flexible resource allocation scheme compared to a fixed resource allocation scheme in previous work.

\subsection{System model}\label{subsec:system-model}
\begin{wrapfigure}{r}{0.5\linewidth}
    \centering
    \includegraphics[width=0.48\linewidth]{figs/system_model.pdf}
    \caption{System Model}
    \label{fig:system-model}
\end{wrapfigure}
A sketch of the system is shown in Fig.~\ref{fig:system-model}.
We assume that there are a set of servers $I = \{1,2,\ldots,\left|I\right|\}$, which could be accessed either through
cellular base stations or WiFi access points (APs). These servers have different types of limited resources:
storage for the code/data needed to run a task (e.g., measured in Gb), computation capacity in terms of CPU cycles per
time interval (e.g., measured in Ghz), and communication bandwidth to receive the data and to send back the results
of the task after execution per time interval (e.g., measured in Mbit). The servers are assumed to only consider these 
attributes for resource allocation, however future work would wish to explore additional attributes like I/O memory
access per second, GPU usage and more. The servers are also assumed to be heterogeneous in all their characteristics. 
Formally, we denote the storage capacity of server $i$ with $S_i$, computation capacity with $W_i$, and the 
bandwidth capacity with $R_i$.

The system also contains a set $J = \{1,2,\ldots,\left| J \right|\}$ different tasks that each require service from one
of the servers $I$.
%% TODO maybe add this not as a footnote
\footnote{We focus on a single-shot setting in this paper. In practice, an allocation mechanism would repeat the
allocation decisions described here over regular time intervals, with longer-running tasks re-appearing on consecutive
time intervals. In subsection~\ref{subsec:batching-verse-online-task-allocation} to evaluate the effectiveness 
of the mechanism batched, we leave a detailed study of this to future work.} Each task has a monetary value, denoted $v_j$,
representing the maximum price the owner is willing to pay to compute the task. \\
In order to run a task requires the server to load the appropriate code/data on the server from a source, then to
compute the code of the task and to send back results to the user. Therefore for each of these stages, we consider
separate speeds that the operations could occur at to enable greatest flexibility for the server at each stage. \\
The storage size for the task $j$ is denoted as $s_j$ with the rate that the program is transferred to the server
as $s^{'}_j$. For a task to be computed successfully, it must fetch and execute instructions on a CPU. We consider the
total number of CPU cycles required for the program to be $w_j$, where the number of CPU cycles assigned to the task
per unit of time as $w^{'}_j$. Finally, after the task is run and the results obtained, the latter need to be sent back
to the user. The size of the results for task $j$ is denoted with $r_j$, and the bandwidth used to sent back results to
the user as $r^{'}_j$. \\
In order to force the server to complete the task with a reasonable time, each task sets a deadline, denoted by $d_j$,
representing the maximum amount of time for a task to be completed successfully within. This includes: the time
required to load the data/code onto the server, run it, and send back results to the user. We assume that there
is an \emph{all} or \emph{nothing} task execution reward scheme, meaning that the task value is awarded only if the
task is completed within its deadline.

\subsection{Optimisation problem}
\label{subsec:optimisation-problem}
Given the aforementioned assumptions and variables from the system model, an optimisation problem is constructed as
followed. This problem uses the additional variable $x_{i,j}$ to denote the allocation of a task $j$ that will run on
server $i$.

\begin{align}
    \max & \sum_{\forall j \in J} v_j \left(\sum_{\forall i \in I} x_{i,j}\right) \label{eq:objective} \\
    \mbox{s.t.} \nonumber \\
    & \sum_{\forall j \in J} s_j x_{i,j} \leq S_i, &~ \forall{i \in I} \label{eq:server-storage-constraint} \\
    & \sum_{\forall j \in J} w^{'}_j x_{i,j} \leq W_i, &~ \forall{i \in I} \label{eq:server-computation-constraint} \\
    & \sum_{\forall j \in J} (r^{'}_j + s^{'}_j) \cdot x_{i,j} \leq R_i, &~ \forall{i \in I} \label{eq:server-bandwidth-constraint} \\
    & \frac{s_j}{s^{'}_j} + \frac{w_j}{w^{'}_j} + \frac{r_j}{r^{'}_j} \leq d_j, &~ \forall{j \in J} \label{eq:task-deadline} \\
    & 0 < s^{'}_j, &~ \forall{j \in J} \label{eq:loading-speeds} \\
    & 0 < w^{'}_j, &~ \forall{j \in J} \label{eq:compute-speeds} \\
    & 0 < r^{'}_j, &~ \forall{j \in J} \label{eq:sending-speeds} \\
    & \sum_{\forall i \in I} x_{i,j} \leq 1, &~ \forall{j \in J} \label{eq:server-task-allocation} \\
    & x_{i,j} \in \{0, 1\}, &~ \forall{i \in I},\forall{j \in J} \label{eq:task-allocation}
\end{align}

The objective (eq.~\ref{eq:objective}) is to maximize the total value over all tasks (i.e.\ social welfare) that
are completed within their deadline (eq.~\ref{eq:task-deadline}).
Constraints~\ref{eq:server-storage-constraint},~\ref{eq:server-computation-constraint}
and~\ref{eq:server-bandwidth-constraint} prevent over allocation of server resources to allocated tasks.
For the server's storage capacity (constraint~\ref{eq:server-storage-constraint}), each server's storage must be less
than allocated task's storage requirements. While for the server's computational capacity
(constraint~\ref{eq:server-computation-constraint}), the capacity is limited by a server's allocated tasks
compute resources ($w^{'}_j$). The server's bandwidth capacity (constraint~\ref{eq:server-bandwidth-constraint})
comprises of two parts: the first for loading fo data/code of a task onto the server and the second for sending
back result to the user. \\
To force the task to the completed within its assigned deadline, constraint~\ref{eq:task-deadline} required the sum
of time taken for each stages of the task, completed in series, to be less than the deadline value.
Note that if a task is not allocated to any server, this constraint can be satisfied by choosing arbitrarily
resource speed as these resources do not use up any servers' resources in
constraint~\ref{eq:server-storage-constraint},~\ref{eq:server-computation-constraint}
or~\ref{eq:server-bandwidth-constraint}. \\
Constraints~\ref{eq:loading-speeds},~\ref{eq:compute-speeds},~\ref{eq:sending-speeds} enforce that the resource
speeds for each stage ($s^{'}_j$, $w^{'}_j$ and $r^{'}_j$) are all positive and finite.
Finally, as every task can only be served by at most one server, constraints~\ref{eq:server-task-allocation}
and~\ref{eq:task-allocation} enforce this.

\subsection{Time Complexity}
\label{subsec:time-complexity}
As the optimisation problem as described in Subsection~\ref{subsec:optimisation-problem} is an extension of the
Knapsack problem which is well-studied problem in computer science that known to be NP-Hard.
Therefore the time complexity of the problem is NP-Hard as well due to the problem being an extension of 
Knapsack problem. 
\begin{theorem}
    The optimisation problem in subsection~\ref{subsec:optimisation-problem} is NP-hard.
\end{theorem}
\begin{proof}
    The optimization problem without the constraint~\ref{eq:task-deadline} is a 0--1 multidimensional knapsack
    problem~\cite{knapsackproblems_2004}, which is a generalization of a simple 0--1 knapsack problem. The latter is an
    NP-hard problem~\cite{knapsackproblems_2004}. Given this, it follows that the 0--1 multidimensional knapsack problem
    is also NP-hard. Since optimization problem (Eqs~\ref{eq:objective} -~\ref{eq:task-allocation}) is a
    generalization of a 0--1 multidimensional knapsack problem, it follows that it is NP-hard as well.
\end{proof}

\subsection{Example Problem Case}
\label{subsec:example-problem-case}
\begin{wrapfigure}{l}{0.6\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figs/allocation/optimal_fixed_resource_allocation.png}
    \caption{Optimal solution with fixed resource speeds}
    \label{fig:example-fixed-allocation}
\end{wrapfigure}
Before we propose our novel allocation mechanisms in the next section, we present an example case to illustrate 
why elasticity is important. In this example, there are 12 potential tasks and 3 servers with the flexible solution able 
to achieve XX\% better social welfare compared to the fixed resource allocation solution. 
The exact settings can be found in Appendix A with table~\ref{tab:example-tasks-properties}
for the tasks and table~\ref{tab:example-servers-properties} for the servers. \\
The figures~\ref{fig:example-fixed-allocation} and~\ref{fig:example-flexible-allocation} represents each server as a
group of three bars, each relating to the each server's resource types, with the percentage of resources used by a task
being the size of the bar.

\begin{wrapfigure}{r}{0.6\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figs/allocation/optimal_flexible_resource_allocation.png}
    \caption{Optimal solution with elastic resources speeds}
    \label{fig:example-flexible-allocation}
\end{wrapfigure}

Figure~\ref{fig:example-fixed-allocation} shows the best possible allocation if tasks have fixed resource speeds (that
were set by minimising the total amount of resources to be completed within the deadline). Here, only 9 of the tasks
are run, resulting in a total social welfare of 980 due to server 1 and 2's limited computational capacity and server
3' limited communication capacity.

In contrast to figure~\ref{fig:example-fixed-allocation}, Figure~\ref{fig:example-flexible-allocation} depicts the optimal
allocation if elastic resources are considered. Here, all of the resources are used by the servers whereas the fixed
example~\ref{fig:example-fixed-allocation} cant do this. In total, the elastic approach manages to schedule all 12 tasks
within the resource constraints, achieving a total social welfare of 1200 (an 18\% improvement over the fixed approach).